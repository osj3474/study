# 정렬 알고리즘

#### \< 선택 기준 >

- 정렬할 데이터의 양

- 데이터와 메모리

- 데이터가 정렬된 정도

- 필요한 추가 메모리의 양

- 상대 위치 보존 여부

  - 안정 vs 불안정

    원래가 `1 1' 3 5 6 ` 이라면 

    - 안정 : `1 1' 3 5 6` 이 되고
    - 불안정 : `1' 1 3 5 6` 이 되는 것이다.

    ex) 속성이 2개 일 때, 안정하게 정렬되는 것은 나이로 먼저 소팅하고, 키로 소팅했을 때 올바르게 정렬되는 것이다.

  

#### \< 종류 >

1. 퀵 정렬

   : 한 피봇을 고르고 이를 기준으로 작은 집합, 큰 집합으로 나눈다. 피봇을 어떻게 선택하느냐에 따라 성능이 달라진다. 시간 복잡도는 O(nlogn) 이며, 최악의 경우 O(n^2)가 된다.

2. 선택 정렬

   : 배열을 훑으면서 가장 작은 키를 찾아 swap하는 방식으로 정렬한다. 최악의 경우 O(n^2)의 시간 복잡도를 가지고, 원소를 움직이는 비용이 비교하는 비용보다 낮은 경우 사용된다.

3. 삽입 정렬

   : 한 원소씩 정렬 기준에 맞는 위치에 삽입하는 방식으로 정렬한다. 최악의 경우 O(n^2)의 시간 복잡도를 가지지만, 이미 정렬되어 있는 상황에서 새로운 원소를 넣는 시간복잡도는 O(n) 으로 효율적이다.

4. 합치기 정렬

   : 두 개의 부분집합으로 나누고 정렬하여 이를 다시 정렬된 형태로 합치면서 정렬한다. 시간복잡도는 O(nlogn)이며, 다른 정렬 알고리즘보다 O(n) 메모리가 추가로 필요하다는 단점이 있다.



#### \< 참고 도표 >

![image](https://user-images.githubusercontent.com/42775225/135756124-3ca0c456-696d-44e1-995b-1c9bc867c651.png)



