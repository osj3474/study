# 자바 면접 스터디



#### 1. JVM 이란 무엇인가요?

: 운영체제에 구애받지 않고 자바 어플리케이션을 실행할 수 있게 해주는 가상 환경이다. 가비지 컬렉션으로 메모리 관리를 해준다. 

구성]

- Class Loader
- Execution Engine
- Interpreter
- JIT (just in time, 컴파일 방식의 실행 방식)
- Garbage collector



#### 2. 자바 프로그램 실행과정은 어떻게 되나요?

1) JVM이 OS로부터 프로그램이 필요로하는 메모리를 할당받습니다.

2) 자바 컴파일러로 소스코드를 바이트코드로 변환시킵니다.

3) Class Loader가 class파일을 JVM으로 로딩합니다.

4) Excecution engine이 로딩된 class파일을 해석하여 실행합니다.



#### 3. 객체지향 프로그래밍이란?

객체, 즉 하나의 사물처럼 단순한 명령어가 아닌, 독립된 단위로 프로그래밍하는 패러다임을 말합니다.

1) 추상화 (공통적인 특징을 하나의 집합으로 다룬 것)

2) 캡슐화 (클래스의 속성과 행동을 하나로 묶고, 정보를 은닉할 수 있는 것)

3) 상속 (기본 클래스를 기반으로 특화된 개체를 만들 수 있는 것)

4) 다형성 (사용할 메서드의 정의를 선택할 수 있는 것. 오버로딩, 오버라이딩)



#### 4. 접근제한자란 어떤 것인가요?

- private : 자기 클래스 내부의 메서드에서만 접근 허용
- protected : 자기 클래스 내부 또는 상속받은 자식 클래스에서 접근 허용
- public : 모든 접근을 허용한다.



#### 5. 객체지향적 설계원칙은 어떻게 되나요?

- SRP(Single Responsibility Principle)단일 책임 원칙
  - 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
- OCP(Open-Closed Principle) : 개방-폐쇄 원칙
  - 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
  - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
  - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
- DIP(Dependency Inversion Principle) : 의존 역전 원칙
  - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.





#### 6. java의 non-static 메서드 static 메서드의 차이는 무엇인가요?

![image-20210220161133383](C:\Users\KTDS\AppData\Roaming\Typora\typora-user-images\image-20210220161133383.png)

: 즉, static 메서드는 객체를 생성하지 않아도 사용할 수 있다. 위에서는 test1()함수를 실행하기 위해서는 test객체가 필요하다.



#### 7. java의 non-static 멤버와 static 멤버의 차이는 무엇인가요? 

: static멤버는 객체를 생성하지 않고도 사용할 수 있다. 또한, 클래스 하나당 하나로 글로벌하게 사용할 수 있어서 공유되어지는 값이다. 

cf) 바로 초기화를 해야할까? => final로 할려면 꼭 초기화를 해야한다. 아닌 경우는 default 0이다.

=> 초기화를 해주면, 파일 크기가 커지고, 초기화를 안해주면 실행시간에 delay가 생긴다.

(값이 변경 불가하도록 하는 변수는 final이다.) ❌

(final 은 재할당을 막는 것이다.)





#### 8. java의 제네릭이란 무엇인가?

: 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다.





#### 9. 레퍼타입과 기본타입

- 기본 타입 : stack에 저장
- 레퍼 타입 : heap에 저장



#### 10. java에서의 쓰레드

##### [1] 생성

1) Runnable로 구현

: `implements Runnable` 로, Thread 생성 시, 인스턴스화 해야함.

2) Thread로 구현

: `extends Thread`로, 이것 자체가 Thread임.

cf) 콜스택이란?

: 실질적인 명령어들을 담고 있는 메모리.



cf) 둘다 실행은 되지만 이런 차이가 있다.

- start()를 쓰면, 알아서 콜스택을 생성해서 쓰레딩 하는 것. 
- run()을 쓰면, 그냥 run함수를 사용하는 것.

 

   



#### 11. 고유락





## 12. abstract vs interface

#### 1) `abstract` 

✅ 무엇인가?

​	=> `자체로는 객체 생성이 되지 않는, 상속을 받아 사용하는 클래스이다.`

✅ 왜 쓰는가?

​	=> `코드를 공유할 수 있다.(추상 메서드 말고, 일반 메서드도 구현 가능하기 때문) `

​	=> `상속받는 클래스는 추상 클래스의 메서드 또는 변수가 있음을 보장한다.` 

​	=> `non-static, non-final 변수를 사용할 수 있어 객체의 상태를 수정할 수 있다.`

✅ 어떻게 쓰나?

```java
// 선언
public abstract class Person{
  public abstract void eat();  // 추상 메서드
  public void work(){	         // 일반 메서드
    
  }
}

// 상속
public class Student extends Person{
  public void eat(){           // 오버라이딩
    
  }
}
```



#### 1) `interface` 

✅ 무엇인가? 

​	=> `자체로 객체 생성이 되며, only 선언들의 집합이다.` (그것도 추상 메서드, static, final 변수만)

✅ 왜 쓰는가?

​	=> `다중 상속을 가능하게 해준다. (C++은 여러 클래스를 상속받을 수 있지만, Java는 하나의 클래스만 상속받을 수 있다.)`

​	=> `상속받는 클래스는 추상 클래스의 메서드 또는 변수가 있음을 보장한다.`

✅ 어떻게 쓰나?

```java
// 선언
public interface Person{
  public String name = "홍길동";    // 변수 선언 (final만 가능)
  public void eat();              // 메서드 선언
}

// 사용
public class Student implements Person{
	private int score;              // 변수 선언
  Student(int score){             // 생성자
    score = score;
  }                     
  public void study(){            // 메서드 선언
    
  }
  public void eat(){              // 오버라이딩
    
  }
  
}
```









<br />

### Java vs Python

|        | Java                                                         | Python                                                       |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 메모리 | JVM에서 Garbage Collection을 수행하며,<br />대상은 heap영역. | [ Python Garbage Collection ]<br /><br />추가설명 필요.      |
| 실행   | [작동 방식]<br /><br />1) `컴파일러` : 모든 소스코드(.java) => 바이트코드(.class) <br />2) `JVM` : 운영체제에 맞는 기계어로 변환 <br /><br />=> 컴파일 시간이 소요되지만, 실행 속도는 빠름. | [작동 방식]<br /><br />1) `Interpreter` : 한 줄씩 해석하여 실행<br /><br />=> 실행 단계에서 해석되기 때문에, 실행 속도는 느림.<br />(변수 타입을 명시하지 않기 때문에, 검사하여 값을 사용해야 함.) |
| 자료형 | 정적유형 (타입선언 O)                                        | 동적유형 (타입선언 X)                                        |
| 스레딩 | 스레드 생성 및 제어와 관련된 <br />라이브러리 API를 제공하고 있기 때문에, <br />운영체제에 상관없이 멀티 스레드를 구현할 수 있음. | 인터프리터 언어이기 때문에, 싱글 스레드 이며,<br />별도 모듈을 이용 해야함. |



cf) <a href="https://soooprmx.com/archives/11330" target='_blank'>언어를 스크립트 언어, 인터프리 언어로 구분하는 것이 옳은 방법일까?</a>











1. Java의 대표 Collection에는 어떤 것들이 있나요?

   => 자바의 대표 Collection에는 List, Map, Set, Stack, Queue와 같은 것들이 있습니다. 이 추상화 된 Collection 인터페이스 아래, 특정한 기법으로 구현된 자료구조가 들어갑니다. 예를 들어, List라는 인터페이스에는 구현 방법에 따라 ArrayList가 들어갈 수도, LinkedList가 들어갈 수도 있습니다.

2. List에 대해 설명해주세요.

   => 리스트는 배열과 비슷한 자바의 자료형으로 배열보다 편리한 기능을 많이 가지고 있습니다. List에는 대표적으로 ArrayList와 LinkedList가 있습니다. ArrayList는 자바의 Vector를 개선한, 배열로 구현된 List입니다. 배열과 같은 자료구조이기 때문에, 리스트의 연산 수행시간 속도는 배열과 같습니다. LinkedList는 다음 노드릐 주소를 기억하고 있는 List로, 배열에 비해 삽입과 삭제가 간단하다는 장점이 있습니다.

3. Map에 대해 설명해주세요.

   => Map에는 HashMap, TreeMap, LinkedHashMap이 있습니다. 그 중 HashMap은 가장 일반적으로 사용하는 Map입니다. HashTable을 사용하며 Key값에 해시함수를 적용하여 나온 index에 Value를 저장하는 식입니다. 중복을 허용하지 않으며, 순서가 없다는 것이 특징이라고 할 수 있습니다. TreeMap은 Red-Black Tree 자료구조를 이용한 Map이고, Tree구조이기 때문에 어느 정도 순서를 보장합니다. LinkedHashMap은 LinkedList로 구현된 HashMap입니다. List로 구현되어 있기 때문에 순서가 보장됩니다. 하지만 LinkedList 특성상 랜덤 접근에서는 느릴 수 있습니다.

4. Set에 대해 설명해주세요.

   => Set에는 HashSet, TreeSet, LinkedHashSet이 있습니다. HashSet은 HashMap에서 Key값이 없는 자료형이고 집합이라고 생각해도 무방합니다. 값이 포함되어 있는지 아닌지에만 관심이 있고 순서를 보장하지 않으며, 중복 값을 허용하지 않습니다. Set 중에는 가장 많이 사용됩니다. TreeSet은 Red-Black Tree 자료구조를 사용한 Set입니다. LinkedHashSet은 LinkedList로 구현된 HashSet으로, 순서를 보장합니다.

5. Stack & Queue에 대해 설명해주세요.

   => Stack과 Queue 모두 데이터를 기록하는 자료구조이며, Stack은 마지막에 넣은 요소가 먼저 나오는 특징이 있는데 반해, Queue는 스택과 반대 개념으로, 먼저 들어간 데이터가 먼저 나오는 구조입니다.

6. Array와 ArrayList의 다른점이 뭔가요?

   => Array는 길이에 대해서 length 변수를 쓰고, ArrayList는 size()메서드를 사용합니다. Array는 크기가 고정되어 있지만, ArrayList는 사이즈가 동적인 배열입니다. Array는 int, byte, char등과 같은 Primitive type과 Object 모두 담을 수 있지만, ArrayList는 Object만 담을 수 있습니다.

https://www.youtube.com/watch?v=Xk9z01AHEQ4&list=LL&index=3





7. HashTable 의 모든것

=> `HashTable`은 기본적으로 정렬되지 않은 배열처럼 동작하며, `key-value 로 데이터를 저장`하는 자료구조입니다. (물론, LinkedHashMap은 sorting되어 있습니다.)

이 때, `Hash Function`과 `Hash Scheme`에 대한 이해가 필요합니다. `Hash Function`은 <u>key에 대한 해시 값(정수)을 반환하는 함수</u>로, 단순히 mod함수부터 xxHash64까지 여러 종류의 함수가 사용이 됩니다. 참고로 실제 속도가 매우 느린 SHA-256(어떤 입력에 대해서든지 256비트 고정 값을 반환, 단방향으로 복호화 불가능)는 사용하지 않습니다. `Hash Scheme`이란 <u>collision(2개의 키가 같은 테이블의 index를 가리키는 경우)을 대처하는 방식</u>을 의미하며,  종류로는 Linear probing(테이블의 빈 공간을 선형 탐색하여 insert/delete/find 함), Robin hood hashing(movement가 일어난 횟수를 함께 저장하여 movement를 균등하게 하여 linear probing의 성능을 향상시킨 방식), Cuckoo hashing이 있습니다.







1. Collection

   : 자바의 대표 Collection에는 List, Map, Set, Stack, Queue와 같은 것들이 있습니다. 이 추상화 된 Collection 인터페이스 아래, 특정한 기법으로 구현된 자료구조가 들어갑니다. 예를 들어, List라는 인터페이스에는 구현 방법에 따라 ArrayList가 들어갈 수도, LinkedList가 들어갈 수도 있습니다.

2. 추상클래스 vs 인터페이스

   : 추상클래스(abstract는 공통 로직 내용(바디)을 가지고 있음)는 상속받는 클래스들의 공통적인 로직을 추상화시키고, 자식클래스들이 부모클래스를 확장시키기 위해 사용합니다. 

   : 인터페이스(interface는 @override)는 그 인터페이스를 구현하는 모든 구현체들은 인터페이스가 정의해둔 같은 기능을 구현하도록 강제 함에 있어 사용합니다.

3. 자바 쓰레드

   : 요청마다 쓰레드가 필요한데, Servlet이 멀티 쓰레드로 동작한다.

   ex) 채팅 앱에서 파일 전송을 보내면서 계속 채팅을 할 수 있는 것이다.

   1. Runnable 인터페이스를 구현

      : `implements Runnable` 하고, `run()` 추상 메서드에 작업 내용을 구현하면 된다.

      : 사용할 때는 `Thread` 타입으로 인스턴스화 해야함. (new로 생성이 필요하다는 말.)

      : `Thread` 인스턴스는 `start()` 메서드로 실행.

   2. Thread클래스를 상속

      : `extends Thread` 하고, `run()` 메서드를 오버라이딩해서 작업 내용을 적으면 된다. 

      : 이것 자체가 Thread임. `start()` 메서드로 실행한다.

   cf) 콜스택이란?

   ​	: 실질적인 명령어들을 담고 있는 메모리.

   cf) 둘다 실행은 되지만 이런 차이가 있다.

   - start()를 쓰면, 알아서 콜스택을 생성해서 쓰레딩 하는 것.

4. final, static

   : static멤버는 객체를 생성하지 않고도 사용할 수 있다. 또한, 클래스 하나당 하나로 글로벌하게 사용할 수 있어서 공유되어지는 값이다.

   : final 은 처음에 반드시 초기화를 해줘야 하는데, 역할은 재할당을 막는 것이다.

5. 다형성 (overloading vs overriding)

   :  객체 지향에서 다형성은 오버라이딩(Overriding)과 오버로딩(Overloading)이라고 할 수 있습니다.

   - **오버라이딩:** 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 정의
   - **오버로딩:** 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

6. GC

   : Grabage Collector는 동적으로 할당한 메모리 영역 중 사용하지 않는 영역을 탐지하여 데이터를 정리하는 기능이다. Heap은 인스턴스와 배열이 동적으로 생성되는 공간으로 GC의 대상이 되는 영역이다.

   [GC]

   - Minor GC : new/young generation 에 unreachable object를 marking하고 sweep한다.
   - Major GC : old generation 에 unreachable object를 marking하고 sweep한다.

   [Heap 구성]

   - new/young generation

     - eden : 객체가 동적으로 생성되면 가장 처음 저장되는 공간이다.

     - survivor 0 : eden이나 survivor1에 남은 reachable object가 옮겨지는 곳.

     - survivor 1 : eden이나 survivor0에 남은 reachable object가 옮겨지는 곳.

       cf) survivor0, survivor1 둘중 하나는 반드시 비어있다.

   - old generation

   [단계]

   1. 가비지컬렉터가 Stack의 모든 변수를 스캔하면서 어떤 객체를 참고하고 있는지 확인한다.
   2. Recachable Object가 참조하고 있는 객체도 찾아서 마킹한다.
   3. 마킹되지 않은 객체를 Heap에서 제거한다

7. JVM 동작

   : (해당 플랫폼 용의 JVM만 설치하면) 운영체제에 구애받지 않고 자바 어플리케이션을 실행할 수 있게 해주는 가상 환경이다. 가비지 컬렉션으로 메모리 관리를 해준다. 

   구성]

   - Class Loader

     : Runtime시에 동적으로 클래스를 로드한다. (클래스 파일을 읽는 파트)

   - Execution Engine

     : 클래스를 실행시키는 역할이다. 클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 실행엔진이 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.

   - Runtime data area

     : 자바 바이트 코드를 실행하기 위해 사용하는 메모리 공간. 쓰레드가 공유하는 것이 있고(method area, heap), 공유하지 않는 것(PC Register, JVM Stack, Native Method Stack)이 있습니다.

     - Method Area

       : 클래스 정보를 저장하기 위한 메모리 공간입니다. 사실상 바이트코드의 대부분이 올라간다고 봐도 된다. 이 공간에는 Runtime Constant Pool 이라는 별도의 관리 영역도 함께 존재한다.

     - Heap

       : 프로그램을 실행하면서 생성한 모든 객체가 저장되는 곳이다.

     - PC Register

       : 스레드가 어떤 부분을 어떤 명령으로 실행해야 할 지에 대한 기록을 하는 부분으로 현재 수행중인 JVM 명령 주소를 가집니다.

     - JVM Stack (Java Stack)

       : Thread의 Method가 호출될 때 수행 정보 (메소드 주소, 매개변수, 지역변수, 연산스택)가 Frame이라는 단위로 JVM stack에 저장된다. 정적으로 할당한 메모리 영역입니다.

     - Native Method Stack

       : Java가 아닌 다른 언어로 작성된 네이티브 코드들을 위한 공간으로 C code를 실행시켜 Kernel에 접근할 수 있습니다.

   cf) source code > assembly language > machine code

   cf) CPU는 레지스터를 쓰는데, JVM은 왜 stack을 쓸까?

   => 하드웨어에 덜 종속적으로 만들기 위함이다. 왜냐하면, 디바이스마다 레지스터 수가 다르게 됩니다. 즉, 1,2,3번 레지스터를 쓴다면, 해당 디바이스는 반드시 그런 레지스터가 있어야 된다는 것입니다. 따라서, 계산 비용을 더 들여서라도 스택을 사용합니다.

8. JVM 튜닝

   : 흠,,,,, https://d2.naver.com/helloworld/184615 ,,,, ;;;

9. Generic

   : 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다.

10. 어노테이션

    : 인터페이스를 기반으로 한 문법으로, 상속의 개념이 아니다. 

    ```java
    @Target(ElementType.METHOD)       // 메소드 대상으로 적용한다.
    @Retention(RetentionPolicy.CLASS) // 사라지는 타이밍. SOURCE하면 컴파일 후에 Aspect 사라짐. 
                                      // (최소 CLASS, RUNTIME)
    public @interface MyAnnotation{
    }
    ```

    주석처럼 코드에 달아두면 런타임 시점에 리플렉션이 적용된다. 

    (리플렉션은 런타임 시점에 클래스의 메서드를 가져다 쓰거나 하는 것인데, 리플렉션이 어노테이션으로만 동작하는 것은 아니지만, 통상적으로 어노테이션으로 리플렉션되는 메서드임을 명시한다.)







# **객체지향**

**상태**와 **행동**을 가진 **객체 단위**로 프로그램을 설계하는 것을 객체지향이라고 합니다.

객체지향은 이미 한번 만들어진 객체에 대한 **재사용성**을 높임으로써 규모 있는 프로그램을 쉽게 **유지보수** 할 수 있게 됩니다.

cf) 절차 지향에 비해 설계가 복잡하고, 메모리 양을 더 많이 사용하며, 상대적으로 속도가 느림.

그런데, 설계하는 방법에 따라 객체지향이 주는 장점을 제대로 얻을 수도 잃을 수도 있습니다.

어플리케이션을 **객체지향으로 설계한다**는 것이란?

**좋은 객체지향**이란?

=> SOLID 원칙

# **SOLID**

핵심은 이것!

=> **역할**을 **인터페이스로 정의**해두고 이를 **상속**받아 여러 개의 **객체**를 만들어 사용. 다른 곳에서 사용할 때는 역할을 바라보도록 한다.

구현체를 아무리 많이 만들더라도 다른 클라이언트와 소통함에 있어 전혀 문제되지 않습니다.

또한, 새로운 구현체가 나오더라도 클라이언트를 바꾸지 않아도 되는 확장성 있는 어플리케이션을 만들 수 있습니다.

![https://user-images.githubusercontent.com/42775225/137076245-11fdf9b8-6c98-4887-8646-f36e08610110.png](https://user-images.githubusercontent.com/42775225/137076245-11fdf9b8-6c98-4887-8646-f36e08610110.png)

- **SRP** : 단일 책임 원칙 (single responsibility principle)

  - 한 클래스는 하나의 책임만 가져야 한다.

    (그런데, 책임이라는 말이 조금 모호하기 때문에, 변경이 있을 때 파급 효과가 적으면 책임 원칙을 잘 따른 것이다.)

    - 수정이 필요할 경우 수정되는 이유는 하나 때문이어야 한다.

- **OCP** : 개방-폐쇄 원칙 (Open/closed principle)

  - 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

  - 다형성을 활용해서 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현

    ex) 새로운 클래스를 **인터페이스를 구현**해서 만드는 것으로 이미 기존 코드 영향 없이 Open에는 열려있는 것이다.

    그런데, 이 클래스를 다른 클래스에서 사용하려고 보니 기존 코드를 변경해야 한다면 다른 클래스는 역할을 바라보고 있지 않고, 구현 클래스를 바라보고 있는 것이다. 즉 이것은 변경에 close되지 않은 것으로 설계 수정이 필요하다.

    => 객체를 생성하고, 연관관계를 맺어주는 설정자가 필요하고 이것이 IoC컨테이너이다.

    - 수정에는 닫히고, 확장에는 열어라.

- **LSP** : 리스코프 치환 원칙 (Liskov substitution principle)

  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

  - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.

    ex) 컴파일의 문제가 아니라, 실제 사용함에 있어서 '자동차의 엑셀은 적어도 앞으로 가야한다.' 를 지키는 것이다.

    - 추상객체로 사용되는 부분에 구상객체가 들어가도 아무 문제 없어야 한다.

- **ISP** : 인터페이스 분리 원칙 (Interface segregation principle)

  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

    ex) 인터페이스를 대체 가능성 높게 역할을 설정해서 만들자.

- **DIP** : 의존관계 역전 원칙 (Dependency inversion principle)

  - 역할에 의존하게 해야 한다는 것이다.

⇒ 역할과 책임을 분리해서 역할은 인터페이스로 구현하고, 책임은 인터페이스를 상속받은 구현 클래스로 사용하게 합니다. 그리고 다른 객체를 사용할 때 인터페이스를 바라보도록 설계합니다.

그런데, 아래 코드를 보면, 인터페이스 타입이긴 하지만 구현 클래스에 의존하고 있기 때문에 결국 코드를 변경해야 한다.

```java
interface 요리사{}

public class Restaurant{
  //private 요리 pastaChef = new 파스타요리사();
   private 요리 steakChef = new 스테이크요리사();

}
```

우리가 원하는건,

```java
interface 요리사{}

public class Restaurant{
  private 요리사 chef;

}
```

이렇게만 해두고, 클라이언트가 원하는 요리를 해달라고 할 때마다 그에 맞는 요리사를 주입해서 하는 방법이 필요한 것이다.

즉, **구현 객체를 생성**하고, **연결해주는 것**은

# **스프링이 해준다**

### **1) IoC**

: Inversion of Control의 약자로, 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주입 받아 사용하여 프로그램의 흐름을 외부가 가져간 것이다.

### **2) DI**

: Dependency Injection의 약자로, 어플리케이션 런타임 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달하는 것이다.

쉽게 말하면,

```java
private BookRepository bookRepository;
```

이렇게만 선언하면 null일텐데, 스프링이 `bookRepository` 에 대한 정보를 주입을 해줘서 바로 사용을 할 수 있다.

### **3) IoC 컨테이너**

: Bean들을 가지고 IoC 기능을 제공하는 컨테이너이다.

ex)

- BeanFactory : IoC컨테이너 최상위 인터페이스이다.
- ApplicationContext : BeanFactory를 상속받은 IoC컨테이너로, 가장 많이 사용한다.

### **3) Bean**

: **IoC 컨테이너에 의해 관리되는 객체**이다.

### **장점**

1. IoC컨테이너에 의해 **의존성 관리**가 된다.

2. IoC컨테이너에 등록된 Bean은 기본적으로 **싱글톤**으로 등록되어 싱글톤으로 사용하려고 할 때, 편하다.

   cf) 스코프

   - 싱글톤 : 하나만 만들어서 전체에 사용하는것
   - 프로토타입 : 매번 다른 객체

3. **라이프 사이클 인터페이스** 로 부가적인 작업을 할 수 있다.

   (Bean에 등록되면서 호출되는 메서드들을 이용하는 경우를 말한다.)

   [순서]

   1. 컨테이너 생성
   2. 의존 관계 주입
   3. 초기화 콜백 (⭐️)
   4. Activation
   5. 소멸 전 콜백 (⭐️)
   6. 종료

# **스프링 부트 실행 과정**

[Spring vs. Srping boot](https://www.notion.so/91ed7fec5e4b48b681931c0bfc201e07)

: 기본적으로 Spring은 버전 명시부터해서 dependency 파일이 엄청 긴데, 부트는 버전 관리도 쉬우며, dependency 파일도 짧아졌다.

: 기본적으로, Spring에 비해 tomcat이 내장되어 있어서 편리하다.

: 기본 Spring이라면 configuration에서 빈 등록하는 것만해도 엄청난 일이다. 부트는 컴포넌트 스캔.





### 디자인 패턴

- Singleton 패턴 : 어플리케이션에 하나만 존재해야하는 객체에 대하여 사용합니다. 구현 방법은 생성자를 private 으로 하고 다른 클래스에서 생성할 수 없도록 합니다. 그리고 자기 자신의 타입의 객체를 static (컴파일 시점에 사용할 메모리가 정해짐)으로 둡니다. 해당 객체를 사용할 때는 호출된 적이 없다면 생성해서 반환하고, 이전에 호출된 적이 있다면 생성되었던 객체를 반환합니다.

  그런데, 이는 멀티 쓰레드 환경에서 오류를 낳을 수 있다??

  - 그래서 해당 객체는 상태를 가지면 안됨.

  ex) 어플리케이션의 테마나 설정에 대한 객체는 반드시 1개여야 합니다.

- Strategy 패턴 : 카테고리와 같이 옵션들마다의 행동이 다를 때, 이를 모듈화해서 독립적이고 상호 교체 가능하게 만드는 방식입니다. 인터페이스를 만들어서 각 카테고리의 기능을 클래스로 implements해서 구현합니다. 그리고는 사용처에서 인터페이스 타입으로 특정 카테고리의 클래스를 new로 사용합니다.

  ex) 카테고리를 선택하는 경우에 사용됩니다.

  > OCP를 지키는 방식의 패턴

- State 패턴 : 상태마다 행동이 다른 경우에 해당됩니다. 우선 각 상태의 행위를 정의하는 클래스를 상태 인터페이스를 구현해 만듭니다. 이 행동 끝에는 다음 상태로 상태를 설정하여 상태를 이전합니다. 메인에서 사용할 때는 상태 인터페이스 타입으로 특정 상태의 클래스를 new로 생성하여 사용합니다.

  ex) 티비의 전원 버튼을 누를 때, 티비가 꺼져있으면 버튼은 키는 것이 되고, 티비가 켜져있으면 버튼은 끄는 것이 됩니다.

- Command 패턴 : abstract(추상) 클래스에 

- Adapter 패턴 : 다른 팀에서 짠 코드를 우리 팀에서 사용해야하는 경우 사용됩니다. 인터페이스 명도 다르고 메서드 명도 다르기 때문에 우리 팀에서 사용하는 인터페이스를 상속받는 (어댑터) 클래스를 하나 만듭니다. 그 클래스 안에 

  ex) 11번가가 아마존과 함께 콜라보를 하게 되었는데, 11번가에서 아마존 상품을 구매할 수 있게 된 것입니다. 그런데 그런 경우 11번가에서 상품을 보여주는 방식의 클래스와 아마존의 클래스가 맞지 않을 것이고, 이의 어댑터 역할이 필요하게 됩니다.



### 스프링 배치란?

: 배치라는 것은 지정한 시간에 주기적으로 특정 작업을 수행하는 것이지만, 스프링의 배치는 대용량 처리에 그 목적을 두고 있습니다. JobLauncher, Job, Step을 정의할 필요가 있다. 데이터 한 row를 Item이라 하고, ItemReader(Cursor방식은 1개의 row, Paging방식은 page단위의 row)로 읽고, ItemProcessor로 비지니스 로직을 수행하고, itemWriter로 쓰게 됩니다. 이 때, Step은 Tasklet과 Chunk(한번의 커밋에 처리될 row수)로 구성되는데, Chunck만큼씩 수행됩니다.

\<기억할 점>

- 테스트 코드를 작성할 때,  복잡한 쿼리를 사용하고 DB까지 저장하는 작업이기 때문에 통합테스트가 필요하다.
- 리눅스 스케줄러인 Cron 또는 Quartz(쿼츠, 스케줄링 프레임워크)를 이용해도 되지만, Jenkins와 같은 CI툴을 이용해 관리하는 방법이 좋다. 왜냐하면 Slack이나 Email로 연동도 쉽고, 실행 방법(REST API, 스케줄링, 수동실행)이 다양하며, 로그 관리도 쉽기 때문입니다. 또 사실 배치에서 Job내부에서 Step을 여러 단계를 나누는 것보다 Jenkins에서 파이프라인을 이용할 수 있어서 Job 단위로 단계를 구현할 수도 있습니다. Job을 단독으로 사용할 수 있도록 해두면 유지보수 측면에서 좋기 때문입니다.

\<특징>

- 배치 어플리케이션은 사용자와의 상호작용 없이 이어지는 프로그램들의 실행이다.
- PageSize만큼 DB에서 읽어오고, chunckSize만큼 DB에 커밋한다.
- 스프링 배치는 외부에서 파라미터를 주입받아서 Batch컴포넌트에서 사용할 수 있다. 이를 Job parameter라고 한다.





### 로그인

: 세션/쿠키 혹은 jwt토큰을 사용하는 방안이 나온 이유는 http프로토콜이 비연결지향이고 stateless하기 때문인데요. 다시 말해서, 각 http 요청은 독립적이며, 이전 요청과 현재 요청이 같은 사용자로부터 온 것인지 알 수 없다는 것입니다. 저는 확장성 측면에서 두 방법 중 하나를 선택하는 것 같습니다.

- 세션/쿠키 : 사용자가 웹서버에 request를 보낼 때, 새로운 사용자면 response에 set-cookie헤더에 세션 ID를 담아 보냅니다. 이 때, 해당 사용자에 대한 고유 ID(세션 ID)를 서버에 저장합니다. 그러면 클라이언트는 해당 쿠키를 브라우저에 저장하고, 다음 요청 시 부터 request에 쿠키 값을 보내게 됩니다. 그러면 서버는 해당 사용자에 맞는 결과를 보낼 수 있게 됩니다.

  장점은 다른 디바이스에서 연결 끊기가 가능하고, 넥플릭스도 4인 이상 막을 수 있는 그런 점

  다만 모바일에서는 브라우저를 이용 못하니 다른 방식이 필요

  > LB환경에서는 스티키 세션, 세션 스토리지 필요

- jwt 토큰 : 반면 토큰 방식은 사용자의 정보가 서버에 저장되지 않고 토큰에 저장됩니다. jwt(json web token)은 일반적으로 로컬 저장소나 쿠키에 저장됩니다. 서버가 여러 대인 환경에서 로드 밸런싱을 하는 경우라면 세션/쿠키 인증 방식이 정상적으로 작동하기 위해서 스티키 세션과 같은 방식이나 세션 정보를 DB에 저장하는 방식을 사용해야 합니다. 사용자가 웹서버에 request를 보낼 때, 새로운 사용자면 response에 set-cookie헤더에 서버가 encryption한 토큰을 담아 보냅니다.이 때, 해당 사용자에 대한 정보는 따로 가지고 있지 않습니다. 다만, 클라이언트가 다음 요청을 보낼 때, request에 달려있는 토큰을 서버에서 decryption했을 때, 이게 복호화가 되면 인증된 사용자가 맞다는 것을 의미합니다. 그렇게 되면, 사용자 이름과 만료기간을 체크하고 클라이언트에게 원하는 리소스를 던져줍니다. 그렇게 되면, 서버가 여러 대더라도 상관없고, RESTful API 라는 것이 호출마다 독자적인 호출인데 이 또한 만족하게 됩니다. 그런데, 토큰을 탈취 당하면 탈취한 토큰으로 사용자 행세를 할 수 있기 때문에 유효기간을 짧게 가지고 가고 HTTPS을 이용해야 합니다. 다만, 토큰 유효기간이 짧은 것을 대비해서 맨 처음 토큰을 만들 때, 엑세스 토큰과 리프레시 토큰을 같이 만듭니다. 클라이언트에게는 엑세스 토큰, 리프레스 토큰을 둘 다 주고, 서버는 리프레시 토큰만 스토리지에 저장해둡니다. 클라이언트는 만료된 엑세스 토큰을 요청과 함께 던지더라도 브라우저가 알아서 리프레스 토큰을 서버에게 전달합니다. 

  (1) 암호화 방식 (2) 실제 토큰 정보(access에 대한 정보 뿐만 아니라, 어떤 리소스에 접근 가능한지에 대한 정보도 들어있다.) (3) 1,2를 합쳐서 해시를 돌린 값

- OAuth : 다른 웹 사이트에 자신의 정보에 대한 접근 권한을 부여하는 수단입니다. 

  - 리소스 오너(사용자) 

  - 클라이언트(소셜 로그인이 있는 웹사이트) 

  - 리소스/인증 서버(구글, 카톡)

    클라이언트는 리소스 서버에 인증을 받아야 한다. 인증을 받으면 리소스 서버는 클라이언트에게 Authorized redirect URIs를 준다. 인증 과정은 다음과 같다. 리소스 오너가 클라이언트에게 요청을 보내게 되면, 클라이언트는 리소스 오너에게 자신의 clientID와 scope, redirect URIs를 query string으로 한 url을 리소스 오너에게 던진다. (이는, 리소스 서버에 특정 기능을 사용할 것인지를 묻는 것이다.) 그렇게 되면, 리소스 오너는 리소스 서버에게 자신의 ID, PW로 로그인을 거친다. 로그인이 되면, 리소스 서버는 리소스 오너에게 authorization code를 붙인 url로 이동하라는 명령을 브라우저에게 한다. 그러면 리소스 오너는 클라이언트에게 해당 url에 대한 요청을 보내고 클라이언트는 authorization code를 알게 되고, 이제 클라이언트는 지금까지의 모든 정보를 보낸다. authorization, clientID, client secret, redirect uri를 보내고 이 정보가 맞다면 리소스 서버는 authorization code를 지우고, 엑세스 토큰을 encryption해서 만들고 클라이언트에게 엑세스 토큰을 던진다. 
