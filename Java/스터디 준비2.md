# 의존관계 주입 방법

1. 생성자 주입
   - 생성자가 1개면 @Autowired 생략가능
   
2. 필드 주입

3. 수정자 주입

4. 일반 메서드 주입

   



# 옵션 처리

@Autowired의 required 옵션은 true이다. false이면, 매개변수가 Bean이 아니더라도 에러는 나지 않는데, 아예 해당 메서드가 호출이 안된다.

Bean이 아닌 걸 주입받게 해놨는데, 그게 @Nullable 이면 Bean이 아닌 그 매개변수 객체는 null이 된다.

Optional<>을 쓰면, Optional.empty이 된다.







# 생성자 주입을 선택해라

- 어플리케이션 시작할 때부터 종료까지 의존관계가 변경되지 않는다. 그런데, 생성자 주입은 객체 생성 시 딱 1번만 호출되니 불변하게 설계되는 것이다.
- 순수 자바 코드로 단위 테스트가 가능하다.
  - 매개변수로 `Impl impl = new Impl(new Repository)` 이 된다는 뜻이다.
- final 키워드를 사용할 수 있다. 
  - final 키워드는 초기화를 강제하기 때문에, 컴파일 단계에서 누락된 주입관계를 찾을 수 있다.

 



# 롬복

클래스의 getter, setter, ToString, 생성자를 자동으로 만들어준다.

사용법은 

1. gradle 추가
2. (intellij 기준) preferences > plugins 에 lombok을 install하고, preferences > build > Complier > Annotation Processors > Enbale a.p. 체크



말을 해주고 싶은 어노테이션은

@RequiredArgsConstructor이다. final이 붙어있는 것들로 생성자를 만들어주는데, 이는 생성자 주입을 완전 간단하게 만들어버린다. ⭐️⭐️







# Bean이 중복되는 경우

@Autowired는 타입으로 주입한다.

그런데, 그럴때는 

1. @Autowired 필드명

    : 타입이 같은게 여러개면, 변수명을 보고 비슷한 Bean을 주입한다.

2. @Qualifier

   : 주입받을 때 누구를 주입받을지 지정한다.

   - @Qualifier끼리 매칭하고
   - Bean이름 매칭하고
   - 없으면, 예외 발생

   Qualifier사용할꺼면, 어노테이션 만들고 사용하자.

3. @Primary

   : 등록된 Bean 중에 주입받을 우선순위를 지정한다.

4. list나 map으로 모두 받기

   :  다형성을 이용해서 사용성을 높일 수 있다.







자동 빈 등록을 해동 OCP, DIP를 지킬 수 있다.



수동 Bean 등록은 언제가 좋을까?

- 업무 로직 빈 : Service, Repository 등

  => 자동으로 하는게 낫다

- 기술 지원 빈 : AOP 등

  => 수동으로 하는게 낫다. 이런 빈은 갯수가 많지 않고, 로직이 잘 적용되는지 확인하기 위해서는 수동 설정이 낫다. 또한, 타입 기준으로 같은 Bean이 여러개인 경우에는 수동이 낫다. 수동으로 하면, 어떤 빈이 주입되는지 한 눈에 볼 수 있다.









# 빈 생명주기 콜백

DB 커넥션 풀이란?

: 어플리케이션 서버랑 DB서버랑 미리 맺어두는 것. 요청이 오면 미리 연결해둔걸 재활용하는 방식으로 사용한다. 

DB 커넥션 풀이나 소켓처럼 객체의 초기화와 종료 작업을 어떻게 하는지 알아보자.



빈

객체 생성 > 의존관계 주입

스프링은 의존관계 주입이 끝나면 빈에게 콜백 메서드로 초기화 시점을 알려주고, 스프링 컨테이너가 종료되기 직전에는 소멸 콜백을 보내준다.



스프링 컨테이너 생성 > 스프링 빈 생성 > 의존관계 주입 > 초기화 콜백 > 사용 > 소멸전 콜밸 > 스프링 종료

cf) 객체의 생성과 초기화를 분리하자

: 생성은 생성에만 집중해야한다. 필요한 정보 받고 하는 객체의 생성에만 집중해야한다. 초기화는 어떻게 보면 서비스 로직이고 무거운 로직이다. 

 



1. InitializingBean 인터페이스를 구현하는데(implements)

   - 의존관계 주입이 끝나면 할 명령어를 afterPropertiesSet 메서드에 넣으면 된다.
   - Bean이 종료될 때 할 명령어를 destroy 메서드에 넣으면 된다.

   => 하지만, 스프링 전용 인터페이스로 스프링에 완전히 의존해야한다. 수정할 수 없는 외부 라이브러리를 쓴다면, 스프링을 덧붙일 수가 없어서 사용을 못한다.

2. @Bean(initMethod= "메서드명", destroyMethod="메서드명") 으로 준다.
   => 스프링에 의존하지 않는다. 메서드명을 자유롭게 할 수 있다. 수정할 수 없는 외부 라이브러리를 쓴다 하더라도, 우린 @Bean 옆에 메서드만 기입하면 된다.

   => @Bean의 destroyMethod는 (inferred) 로 등록되어 있어서, `close`, `shutdown` 메서드가 있으면 자동 호출해준다. 안쓸꺼면 destroy=""하면 됨.

3. @PostConstructor, @PreDestroy 를 쓰자. (추천)

   => 해당 메서드에 어노테이션 붙이면 끝. javax로 import하는데, 이는 자바 표준으로 관리되는 것이다. 단, 수정 못하는 외부 라이브러리는 못쓰니 그런 경우는 2번 쓰면 됨.



```java
@PostConstruct
public void init() {
  System.out.println("NetworkClient.init");
  connect();
  call("초기화 연결 메시지");
}

@PreDestroy
public void close() {
  System.out.println("NetworkClient.close");
  disConnect();
}
```



# 빈 스코프

- 싱글톤 : 스프링 컨테이너의 시작과 종료까지 유지됨.
- 프로토타입 : 스프링 컨테이너가 빈을 생성하고 의존 관계 주입까지만 하고 그 이상 관리하지 않음.

- 웹 관련 스코프
  - request : 웹 요청이 들어오고 나갈 때까지 유지됨
  - session : 웹 세션이 생성되고 종료될 때까지 유지됨
  - application : 웹의 서블릿 컨텍스와 같은 범위로 유지됨







# 프로토타입 스코프

클라이언트가 프로토타입 빈을 요청하면 스프링 컨테이너가 생성하고 의존관계 주입해서 클라이언트에게 반환하고는 스프링 컨테이너가 관리 안함.

관리 책임은 클라이언트에게 있음. (@PreDestroy와 같은 종료 메서드 호출 안됨.)



싱글톤과 함께 사용할 때 문제점

싱글톤 빈이 프로토타입 빈을 의존관계 주입받아서 사용한다면, 그렇다면, 프로토타입 빈은 프로토타입이 아니다. (해당 프로토타입 빈은 싱글톤 빈이 생성되고 의존관계 주입받는 시점에 그 빈이다.)

=> 의도한대로 하려면, 스프링 컨테이너(ApplicationContext)를 싱글톤 빈 내부에서 주입받아서 필요할 때마다 직접 컨테이너에게 받는 것이다. (좋지 않은 방법 => 필요한 의존관계를 직접 받는 것을 Dependency Lookup이라 한다.)

=> DL 역할을 하는 Provider를 써보자!



근데, 직접 사용할 일이 거의 없다.



# Provider

싱글톤 빈에서 프로토타입 빈을 쓸 때 사용한다.

### [1] ObjectProvider (ObjectFactory)

- ObjectProvider (ObjectFactory 상속받음)

  ```java
  @Autowired
  ObjectProvider<PrototypeBean> prototypeBeanProvider;
  
  PrototypeBean bean = prototypeBeanProvider.getObject();
  ```

  

### [2] javax의 Provider

자바표준으로 스프링이 다른 컨테이너에서도 사용 가능

- build.gradle에 추가해줘야함

  ```
  implementation 'javax.inject:javax.inject:1'
  ```

- 사용

  ```java
  @Autowired
  private Provider<PrototypeBean> prototypeBeanProvider;
  
  PrototypeBean bean = prototypeBeanProvider.get();
  ```

  



# 웹 스코프

웹 환경에서만 동작함.

스프링이 해당 스코프의 종료시점까지 관리함.



- request

- session

- application

- websocket

  



cf) 포트는 이렇게 바꾸면 된다.

application.properties

```
server.port = 9090
```





# request 스코프

여러 http요청이 왔을 때 정확히 어떤 요청이 남긴 로그인지 구분할 때 이걸 쓴다.!!!!



로그포맷

```
[UUID][requestURL] {message}
```

- UUID : HTTP요청의 unique id
- 지금 예제에서는 Controller에서 하지만, 나중에 스프링 인터셉터나 서블릿 필터 알게되면 거기서 함.



```java
@Component
@Scope(value="request")
public class MyLogger{
	private String uuid;
  private String requestURL;

  public void setRequestURL(String requestURL){
    this.requestURL = requestURL;
  }
  
  public void log(String message){
    System.out.println("["+uuid+"]["+requestURL+"] "+message);
  }
  
  @PostConstruct
  public void init(){
    String uuid = UUID.randomUUID().toString();
  }
  
  @PreDestroy
  public void close(){
    System.out.println("close");
  }
}
```



```java
@Controller
@RequiredArgsConstructor
public class LogDemoController{
  private final LogDemoService logDemoService;
  private final MyLogger myLogger;
  
  @RequestMapping("log-demo")
  @ResponseBody
  public String logDemo(HttpServeltRequest request){
    String requestURL = request.getRequestURL().toString();
    myLogger.setRequestURL(requestURL);
  }
}
```



생각을 해보면 스프링 컨테이너가 의존관계 주입을 할 때는 Request 스코프인 빈은 찾을 수가 없다. 왜냐하면, Request스코프인 빈은 클라이언트의 HTTP요청이 있을 때가 생존의 시작이기 때문이다. 

어떻게 해야할까?

=> Provider를 쓰면 된다.!!!!!!!





```java
@Controller
@RequiredArgsConstructor
public class LogDemoController{
  private final LogDemoService logDemoService;
  private final ObjectProvider<MyLogger> myLoggerProvider;
  
  @RequestMapping("log-demo")
  @ResponseBody
  public String logDemo(HttpServeltRequest request){
    MyLogger myLogger = myLoggerProvider.getObject();
    String requestURL = request.getRequestURL().toString();
    myLogger.setRequestURL(requestURL);
  }
}
```

=> 주입할 때 Request스코프 빈을 쓰는게 아니라, Controller가 요청을 받은 시점에 Provider를 통해서 해당 빈을 얻어 쓴다.





그런데, Provider로 안쓰고 바로 MyLogger 쓸수는 없을까,,,

있다. proxyMode 옵션을 주자

```java
@Component
@Scope(value="request", proxyMode=ScopeProxyMode.TARGET_CLASS)
public class MyLogger{

}
```

=> 이렇게 하면, 가짜 프록시 클래스(CGLIB)를 만들어서 Bean이 주입한다. 요청이 오면, 그때 진짜 빈을 찾는 방법을 알고 있기 때문에 알아서 처리된다.

이러면 myLoggerProvider 안쓰고 바로 myLogger쓰면 됨.



=> Provider든, 프록시든! 요점은 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 것.





















