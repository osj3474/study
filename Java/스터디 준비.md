# 싱글톤

클래스의 인스턴스가 어플리케이션 내에 딱 1개만 있는 것을 말한다.

그런데, 이 패턴은 문제가 있다.

- DIP위반
- OCP원칙 위반
- 유연성이 떨어짐



=> 스프링의 싱글톤 컨테이너

![image-20210704172307247](/Users/sangjin/Library/Application Support/typora-user-images/image-20210704172307247.png)

다시 말해, 스프링에 Bean으로 등록하면, 싱글톤으로 관린된다는 뜻.



다만 주의해야 하는 것이 있는데, stateless하게 설계해야한다.

즉, 싱글톤 객체는 공유되는 것이므로 필드를 업데이트 할 수 있어서는 안된다는 것.



그런데, 우리가 수동으로 의존성 주입을 받고 있다고 해보자.

그러면, Service를 쓸 때, Repository를 new로 생성해서 주입을 받는다. 

(각각이 모두 Bean으로 등록되어야 하고, 같은 Bean이 두번 등록되는건 스프링이 알아서 처리해주었음.)



그냥 생성자 주입으로 가자.

```java
@Controller
class OwnerController {

	private final OwnerRepository owners;
  @Autowired
	public OwnerController(OwnerRepository clinicService) {
		this.owners = clinicService;
	}
}
```





어찌됐든 간에, @Configuration으로 Bean을 설정했을 때의 스프링 컨테이너는 이미 Bean으로 등록된 녀석을 한번더 new하게 되면, new를 무시하고 기존의 Bean을 사용하도록 한다. 이 때의 Bean은 CGLIB라는 새로운 클래스 이름을 갖게 된다.

![image-20210704173328949](/Users/sangjin/Library/Application Support/typora-user-images/image-20210704173328949.png)

그냥 스프링 설정할 때는 @Configuration쓰면 된다.









# 컴포넌트 스캔

@Component 어노테이션 붙어있는 친구들 모두 Bean으로 등록한다.

Bean등록 자동으로 해주는 기능이다.

탐색 위치는 @ComponentScan이 붙어있는 클래스가 속한 패키지로부터 시작된다.

탐색 위치를 설정할 수도 있는데, basePackages로 패키지를 지정할 수도 있다.

Bean으로 포함 시킬 어노테이션(혹은 클래스-ASSIGNABLE_TYPE 등)을 includeFilters로 설정할 수 있고, 제외할 어노테이션(혹은 클래스-ASSIGNABLE_TYPE 등) 을 excludeFilters로 설정할 수도 있다.

부트의 경우 @SpringBootApplication안에 @ComponentScan이 있다.

(즉, @Configuration + @Bean조합으로 등록할 필요 없이, @Component 어노테이션 붙이면 된다는 것.)

의존관계 명시도 @Autowired하나면 끝.

Bean으로 등록할 때의 Bean이름은 클래스의 맨 앞글자를 소문자로 바꾼 이름이 된다. (이름 직접 지정도 가능.)



* 어노테이션에는 상속관계라는게 없음. 스프링의 기능임.



어노테이션을 @interface로 직접 만들어서 사용할 수도 있음.

Bean이 중복 등록되면 어떻게 될까? 

스프링에서는 자동으로 Bean을 등록하는데, 중복이 되면 컴파일 에러 떨어뜨림. 근데, 수동으로 등록한 Bean이랑 자동으로 등록한 Bean이 있는 경우, 수동으로 등록한 Bean이 등록됨.

스프링 부트에서는 그마저도 컴파일 에러.

































