# EntityManger

=> JPA에서 가장 중요한 용어로, 엔티티를 영구 저장하는 환경을 의미한다.

EntityManger(엔티티 매니저)로 PersistenceContext(영속성 컨텍스트)에 접근한다.

어플리케이션과 DB 사이에 있다고 생각하면 된다.



### 1) Entity 생명주기

<img src="https://user-images.githubusercontent.com/42775225/130232698-b56cd54c-74a0-4614-8da0-99807701b541.png" alt="image" style="zoom:50%;" />

- new : 그냥 객체가 만들어진 상태
- managed : 엔티티를 persist한 상태로, DB와는 관계없다.
- detached : 준영속(엔티티를 영속성 컨테스트에서 분리) 상태로, detach메서드에 해당한다.
- removed : DB값도 지우는 것이다. remove메서드에 해당된다.





### 2) persist

: DB에 저장하는 것이 아니다.

: 영속성 컨텍스트에 저장하는 것이다.



![image](https://user-images.githubusercontent.com/42775225/130234626-441fef47-1d94-4254-84e8-1cb85df0a3f8.png)



### 3) 영속성 컨텍스트

: 내부에 1차 캐시가 있다.

(캐시는 Map으로 \<id, Entity>를 가지고 있다. DB를 조회하기 전에 여기부터  찾는다.)

: em은 DB의 트랜잭션당 1개를 만들고, 끝나면 날아간다. (1차 캐시도 포함)

Q1) 트랜잭션 당 1개라는게 이해가 잘 안된다. emf.createEntityManger()로 수동 생성하는건 무엇인지?

Q2) em.getTransaction에서 commit을 하면 insert된다는데, 트랜잭션(begin-commit)을 안 걸면 em이 없는 것인가?





### 4) 플러시

: 영속성 컨텍스트 변경 내용을 DB에 동기화

: 1차 캐시를 지우는 것은 아니다.

: 쓰기지연 SQL에 있는게 DB에 반영이 되는 것이다.

\<하는 방법>

- em.flush()
- 트랜잭션 commit
- JPQL 쿼리 실행시 (SQL을 바로 쓰는 것이니까, ex. em.createQuery("SQL"))





### 5) 준영속 상태

<영속>

1. em.persist로 1차 캐시 올라가거나
2. em.find 했을 때, DB에서 1차 캐시에 넣는 경우

<준영속>

1. 엔티티를 영속성 컨텍스트에서 분리
2. 하는 방법 
   - em.detach(entity)
   - em.clear()
   - em.close()